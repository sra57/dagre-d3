{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","dagre-d3.core.js","lib/arrows.js","lib/create-clusters.js","lib/create-edge-labels.js","lib/create-edge-paths.js","lib/create-nodes.js","lib/d3.js","lib/dagre.js","lib/graphlib.js","lib/intersect/index.js","lib/intersect/intersect-circle.js","lib/intersect/intersect-ellipse.js","lib/intersect/intersect-line.js","lib/intersect/intersect-node.js","lib/intersect/intersect-polygon.js","lib/intersect/intersect-rect.js","lib/label/add-html-label.js","lib/label/add-label.js","lib/label/add-svg-label.js","lib/label/add-text-label.js","lib/lodash.js","lib/position-clusters.js","lib/position-edge-labels.js","lib/position-nodes.js","lib/render.js","lib/shapes.js","lib/util.js","lib/version.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","dagreD3","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","graphlib","dagre","intersect","render","util","version","./lib/dagre","./lib/graphlib","./lib/intersect","./lib/render","./lib/util","./lib/version","2","normal","parent","id","edge","type","marker","append","attr","path","style","applyStyle","vee","undirected","default","./util","3","createClusters","selection","clusters","nodes","filter","v","isSubgraph","svgClusters","selectAll","data","remove","enter","node","applyTransition","each","thisGroup","d3","select","labelGroup","addLabel","clusterLabelPos","c","domCluster","exit","./label/add-label","4","createEdgeLabels","svgEdgeLabels","edges","edgeToId","classed","label","bbox","getBBox","labelId","_","has","width","height","./d3","./lodash","5","createEdgePaths","arrows","svgPaths","adjustEdgePositionsForCategories","domEdge","elem","applyClass","arrowheadId","uniqueId","makeFragmentRef","location","href","calcPoints","arrowhead","forEach","source","hasOwnProperty","numberOfCategories","repositionFirstPointInEdge","w","redrawLoop","graph","points","y","Math","max","ranksep","categoriesPaddingLeft","categoriesPaddingRight","edgesInCategory","outEdges","inSameCategory","sort","sortEdgesBySinkPosition","categoryIndex","indexOf","pctPlacement","categoriesWidth","categoryWidth","nodeLeftX","x","recursiveEdgePadding","recursivesep","x2","x4","p0","x1","y1","y2","y4","x3","y3","e1","e2","edge1","edge2","url","fragmentId","baseUrl","split","tail","head","slice","unshift","intersectNode","push","createLine","line","svg","d","interpolate","lineInterpolate","tension","Number","lineTension","getCoords","matrix","ownerSVGElement","getScreenCTM","inverse","multiply","translate","svgPathsEnter","sourceElem","range","map","svgPathExit","getTotalLength","./intersect/intersect-node","6","createNodes","shapes","simpleNodes","svgNodes","labelDom","shape","pick","paddingLeft","paddingRight","paddingTop","paddingBottom","shapeSvg","shapeBBox","7","8","undefined","9","10","circle","ellipse","polygon","rect","./intersect-circle","./intersect-ellipse","./intersect-node","./intersect-polygon","./intersect-rect","11","intersectCircle","rx","point","intersectEllipse","12","ry","cx","cy","px","py","det","sqrt","dx","abs","dy","13","intersectLine","p1","p2","q1","q2","a1","a2","b1","b2","c1","c2","r1","r2","r3","r4","denom","offset","num","sameSign","14","15","intersectPolygon","polyPoints","intersections","minX","POSITIVE_INFINITY","minY","entry","min","left","top","p","q","pdx","pdy","distp","qdx","qdy","distq","console","log","./intersect-line","16","intersectRect","sx","sy","h","17","addHtmlLabel","root","fo","div","insert","html","labelStyle","client","getBoundingClientRect","../util","18","labelSvg","labelType","addSVGLabel","addTextLabel","labelBBox","./add-html-label","./add-svg-label","./add-text-label","19","domNode","appendChild","20","lines","processEscapeSequences","text","ch","newText","escaped","21","lodash","22","positionClusters","created","23","positionEdgeLabels","24","positionNodes","25","fn","preProcessGraph","outputGroup","createOrSelectGroup","clustersGroup","edgePathsGroup","edgeLabels","layout","postProcessGraph","value","arguments","children","defaults","paddingX","paddingY","padding","NODE_DEFAULT_ATTRS","k","_prevWidth","_prevHeight","EDGE_DEFAULT_ATTRS","name","empty","./arrows","./create-clusters","./create-edge-labels","./create-edge-paths","./create-nodes","./dagre","./position-clusters","./position-edge-labels","./position-nodes","./shapes","26","diamond","SQRT2","join","./intersect/intersect-circle","./intersect/intersect-ellipse","./intersect/intersect-polygon","./intersect/intersect-rect","27","escapeId","str","String","replace","ID_DELIM","dom","styleFn","classFn","otherClasses","isPlainObject","transition","isFunction","28"],"mappings":"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","file":"dagre-d3.core.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * @license\n * Copyright (c) 2012-2013 Chris Pettitt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nmodule.exports =  {\n  graphlib: require(\"./lib/graphlib\"),\n  dagre: require(\"./lib/dagre\"),\n  intersect: require(\"./lib/intersect\"),\n  render: require(\"./lib/render\"),\n  util: require(\"./lib/util\"),\n  version: require(\"./lib/version\")\n};\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dagreD3 = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * @license\n * Copyright (c) 2012-2013 Chris Pettitt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nmodule.exports =  {\n  graphlib: require(\"./lib/graphlib\"),\n  dagre: require(\"./lib/dagre\"),\n  intersect: require(\"./lib/intersect\"),\n  render: require(\"./lib/render\"),\n  util: require(\"./lib/util\"),\n  version: require(\"./lib/version\")\n};\n\n},{\"./lib/dagre\":8,\"./lib/graphlib\":9,\"./lib/intersect\":10,\"./lib/render\":25,\"./lib/util\":27,\"./lib/version\":28}],2:[function(require,module,exports){\nvar util = require(\"./util\");\n\nmodule.exports = {\n  \"default\": normal,\n  \"normal\": normal,\n  \"vee\": vee,\n  \"undirected\": undirected\n};\n\nfunction normal(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n\nfunction vee(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 0 L 10 5 L 0 10 L 4 5 z\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n\nfunction undirected(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 5 L 10 5\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n\n},{\"./util\":27}],3:[function(require,module,exports){\nvar util = require(\"./util\"),\n    addLabel = require(\"./label/add-label\");\n\nmodule.exports = createClusters;\n\nfunction createClusters(selection, g) {\n  var clusters = g.nodes().filter(function(v) { return util.isSubgraph(g, v); }),\n      svgClusters = selection.selectAll(\"g.cluster\")\n        .data(clusters, function(v) { return v; });\n\n  svgClusters.selectAll(\"*\").remove();\n  svgClusters.enter()\n    .append(\"g\")\n      .attr(\"class\", \"cluster\")\n      .attr(\"id\",function(v){\n          var node = g.node(v);\n          return node.id;\n      })\n      .style(\"opacity\", 0);\n\n  util.applyTransition(svgClusters, g)\n    .style(\"opacity\", 1);\n\n  svgClusters.each(function(v) {\n    var node = g.node(v),\n        thisGroup = d3.select(this);\n    d3.select(this).append(\"rect\");\n    var labelGroup = thisGroup.append(\"g\").attr(\"class\", \"label\");\n    addLabel(labelGroup, node, node.clusterLabelPos);\n  });\n\n  svgClusters.selectAll(\"rect\").each(function(c) {\n    var node = g.node(c);\n    var domCluster = d3.select(this);\n    util.applyStyle(domCluster, node.style);\n  });\n\n  util.applyTransition(svgClusters.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgClusters;\n}\n\n},{\"./label/add-label\":18,\"./util\":27}],4:[function(require,module,exports){\n\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    addLabel = require(\"./label/add-label\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = createEdgeLabels;\n\nfunction createEdgeLabels(selection, g) {\n  var svgEdgeLabels = selection.selectAll(\"g.edgeLabel\")\n    .data(g.edges(), function(e) { return util.edgeToId(e); })\n    .classed(\"update\", true);\n\n  svgEdgeLabels.selectAll(\"*\").remove();\n  svgEdgeLabels.enter()\n    .append(\"g\")\n      .classed(\"edgeLabel\", true)\n      .style(\"opacity\", 0);\n  svgEdgeLabels.each(function(e) {\n    var edge = g.edge(e),\n        label = addLabel(d3.select(this), g.edge(e), 0, 0).classed(\"label\", true),\n        bbox = label.node().getBBox();\n\n    if (edge.labelId) { label.attr(\"id\", edge.labelId); }\n    if (!_.has(edge, \"width\")) { edge.width = bbox.width; }\n    if (!_.has(edge, \"height\")) { edge.height = bbox.height; }\n  });\n\n  util.applyTransition(svgEdgeLabels.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgEdgeLabels;\n}\n\n},{\"./d3\":7,\"./label/add-label\":18,\"./lodash\":21,\"./util\":27}],5:[function(require,module,exports){\n\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    intersectNode = require(\"./intersect/intersect-node\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\nmodule.exports = createEdgePaths;\n\nfunction createEdgePaths(selection, g, arrows) {\n  var svgPaths = selection.selectAll(\"g.edgePath\")\n    .data(g.edges(), function(e) { return util.edgeToId(e); })\n    .classed(\"update\", true);\n\n  // Update the first point in the edge so it is shown in the correct category.\n  adjustEdgePositionsForCategories(g);\n\n  enter(svgPaths, g);\n  exit(svgPaths, g);\n\n  util.applyTransition(svgPaths, g)\n    .style(\"opacity\", 1);\n\n  // Save DOM element in the path group, and set ID and class\n  svgPaths.each(function(e) {\n    var domEdge = d3.select(this);\n    var edge = g.edge(e);\n    edge.elem = this;\n\n    if (edge.id) {\n      domEdge.attr(\"id\", edge.id);\n    }\n\n    util.applyClass(domEdge, edge[\"class\"],\n      (domEdge.classed(\"update\") ? \"update \" : \"\") + \"edgePath\");\n  });\n\n  svgPaths.selectAll(\"path.path\")\n    .each(function(e) {\n      var edge = g.edge(e);\n      edge.arrowheadId = _.uniqueId(\"arrowhead\");\n\n      var domEdge = d3.select(this)\n        .attr(\"marker-end\", function() {\n            return \"url(\" + makeFragmentRef(location.href, edge.arrowheadId) + \")\";\n        })\n        .style(\"fill\", \"none\");\n\n      util.applyTransition(domEdge, g)\n        .attr(\"d\", function(e) { return calcPoints(g, e); });\n\n      util.applyStyle(domEdge, edge.style);\n    });\n\n  svgPaths.selectAll(\"defs *\").remove();\n  svgPaths.selectAll(\"defs\")\n    .each(function(e) {\n      var edge = g.edge(e),\n          arrowhead = arrows[edge.arrowhead];\n      arrowhead(d3.select(this), edge.arrowheadId, edge, \"arrowhead\");\n    });\n\n  return svgPaths;\n}\n\nfunction adjustEdgePositionsForCategories(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e),\n        source = g.node(e.v);\n    // Only perform this adjustment if the edge & source node has the required\n    // properties.\n    if (!edge.hasOwnProperty(\"categoryIndex\")\n        || !source.hasOwnProperty(\"numberOfCategories\")\n        || source.numberOfCategories === 0) {\n      return;\n    }\n\n    repositionFirstPointInEdge(g, e);\n\n    if (e.v === e.w) {\n      // Recursive edge.\n      redrawLoop(g, edge, source);\n    }\n    else if (g.graph().hasOwnProperty(\"ranksep\") && edge.points.length > 2) {\n      // Make sure the second point in the edge is at least ranksep from the\n      // source node. This should help make overlapping edges from the same node\n      // easier to follow.\n      edge.points[1].y = Math.max(edge.points[1].y, edge.points[0].y\n        + g.graph().ranksep - 20);\n    }\n  });\n}\n\nfunction repositionFirstPointInEdge(g, e) {\n  var edge = g.edge(e),\n      source = g.node(e.v);\n  var categoriesPaddingLeft = 0;\n  if (g.graph().hasOwnProperty(\"categoriesPaddingLeft\")) {\n    categoriesPaddingLeft = g.graph().categoriesPaddingLeft;\n  }\n\n  var categoriesPaddingRight = 0;\n  if (g.graph().hasOwnProperty(\"categoriesPaddingRight\")) {\n    categoriesPaddingRight = g.graph().categoriesPaddingRight;\n  }\n\n  var edgesInCategory = g.outEdges(e.v).filter(inSameCategory(g, e));\n  // Ensure edges in same category never cross.\n  edgesInCategory.sort(sortEdgesBySinkPosition(g));\n  var categoryIndex = edgesInCategory.indexOf(e);\n  var pctPlacement = (categoryIndex + 1)/(edgesInCategory.length + 1);\n  var categoriesWidth = source.width - categoriesPaddingLeft\n    - categoriesPaddingRight;\n  var categoryWidth = categoriesWidth/source.numberOfCategories;\n  var nodeLeftX = source.x - source.width/2;\n\n  // Assign a new x value for the first point so it is in the correct category.\n  edge.points[0].x = nodeLeftX + categoriesPaddingLeft\n    + categoryWidth * edge.categoryIndex + pctPlacement * categoryWidth;\n  edge.points[0].y = source.y + source.height/2;\n}\n\nfunction redrawLoop(g, edge, source) {\n  var recursiveEdgePadding = 50;\n  if (g.graph().hasOwnProperty(\"recursivesep\")) {\n    recursiveEdgePadding = g.graph().recursivesep;\n  }\n\n  var p0 = edge.points[0];\n  var x1 = p0.x, y1 = p0.y + recursiveEdgePadding;\n  var x2, y2 = y1;\n  var x4, y4 = source.y;\n  if (p0.x < source.x && source.x - source.width/2 - recursiveEdgePadding > 0) {\n    // Wrap around left of node.\n    x2 = source.x - source.width/2 - recursiveEdgePadding;\n    x4 = x2 + recursiveEdgePadding;\n  } else {\n  // Wrap around right of node.\n    x2 = source.x + source.width/2 + recursiveEdgePadding;\n    x4 = x2 - recursiveEdgePadding;\n  }\n  var x3 = x2, y3 = y4;\n\n  edge.points = [edge.points[0], {x: x1, y: y1}, {x: x2, y: y2},\n    {x: x3, y: y3}, {x: x4, y: y4}];\n}\n\nfunction inSameCategory(g, e1) {\n  return function(e2) {\n    return g.edge(e1).categoryIndex === g.edge(e2).categoryIndex;\n  };\n}\n\nfunction sortEdgesBySinkPosition(g) {\n  return function(edge1, edge2) {\n    return g.node(edge1.w).x - g.node(edge2.w).x;\n  };\n}\n\nfunction makeFragmentRef(url, fragmentId) {\n  var baseUrl = url.split(\"#\")[0];\n  return baseUrl + \"#\" + fragmentId;\n}\n\nfunction calcPoints(g, e) {\n  var edge = g.edge(e),\n      tail = g.node(e.v),\n      head = g.node(e.w);\n  var points;\n  if (edge.hasOwnProperty(\"categoryIndex\")\n      && tail.hasOwnProperty(\"numberOfCategories\")) {\n    points = edge.points.slice(0, edge.points.length - 1);\n  } else {\n    points = edge.points.slice(1, edge.points.length - 1);\n    points.unshift(intersectNode(tail, points[0]));\n  }\n  points.push(intersectNode(head, points[points.length - 1]));\n\n  return createLine(edge, points);\n}\n\nfunction createLine(edge, points) {\n  var line = d3.svg.line()\n    .x(function(d) { return d.x; })\n    .y(function(d) { return d.y; });\n\n  if (_.has(edge, \"lineInterpolate\")) {\n    line.interpolate(edge.lineInterpolate);\n  }\n\n  if (_.has(edge, \"lineTension\")) {\n    line.tension(Number(edge.lineTension));\n  }\n\n  return line(points);\n}\n\nfunction getCoords(elem) {\n  var bbox = elem.getBBox(),\n      matrix = elem.ownerSVGElement.getScreenCTM()\n        .inverse()\n        .multiply(elem.getScreenCTM())\n        .translate(bbox.width / 2, bbox.height / 2);\n  return { x: matrix.e, y: matrix.f };\n}\n\nfunction enter(svgPaths, g) {\n  var svgPathsEnter = svgPaths.enter()\n    .append(\"g\")\n      .attr(\"class\", \"edgePath\")\n      .style(\"opacity\", 0);\n  svgPathsEnter.append(\"path\")\n    .attr(\"class\", \"path\")\n    .attr(\"d\", function(e) {\n      var edge = g.edge(e),\n          sourceElem = g.node(e.v).elem,\n          points = _.range(edge.points.length).map(function() { return getCoords(sourceElem); });\n      return createLine(edge, points);\n    });\n  svgPathsEnter.append(\"defs\");\n}\n\nfunction exit(svgPaths, g) {\n  var svgPathExit = svgPaths.exit();\n  util.applyTransition(svgPathExit, g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  util.applyTransition(svgPathExit.select(\"path.path\"), g)\n    .attr(\"d\", function(e) {\n      var source = g.node(e.v);\n\n      if (source) {\n        var points = _.range(this.getTotalLength()).map(function() { return source; });\n        return createLine({}, points);\n      } else {\n        return d3.select(this).attr(\"d\");\n      }\n    });\n}\n\n},{\"./d3\":7,\"./intersect/intersect-node\":14,\"./lodash\":21,\"./util\":27}],6:[function(require,module,exports){\n\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    addLabel = require(\"./label/add-label\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = createNodes;\n\nfunction createNodes(selection, g, shapes) {\n  var simpleNodes = g.nodes().filter(function(v) { return !util.isSubgraph(g, v); });\n  var svgNodes = selection.selectAll(\"g.node\")\n    .data(simpleNodes, function(v) { return v; })\n    .classed(\"update\", true);\n\n  svgNodes.selectAll(\"*\").remove();\n  svgNodes.enter()\n    .append(\"g\")\n      .attr(\"class\", \"node\")\n      .style(\"opacity\", 0);\n  svgNodes.each(function(v) {\n    var node = g.node(v),\n        thisGroup = d3.select(this),\n        labelGroup = thisGroup.append(\"g\").attr(\"class\", \"label\"),\n        labelDom = addLabel(labelGroup, node),\n        shape = shapes[node.shape],\n        bbox = _.pick(labelDom.node().getBBox(), \"width\", \"height\");\n\n    node.elem = this;\n\n    if (node.id) { thisGroup.attr(\"id\", node.id); }\n    if (node.labelId) { labelGroup.attr(\"id\", node.labelId); }\n    util.applyClass(thisGroup, node[\"class\"],\n      (thisGroup.classed(\"update\") ? \"update \" : \"\") + \"node\");\n\n    if (_.has(node, \"width\")) { bbox.width = node.width; }\n    if (_.has(node, \"height\")) { bbox.height = node.height; }\n\n    bbox.width += node.paddingLeft + node.paddingRight;\n    bbox.height += node.paddingTop + node.paddingBottom;\n    labelGroup.attr(\"transform\", \"translate(\" +\n      ((node.paddingLeft - node.paddingRight) / 2) + \",\" +\n      ((node.paddingTop - node.paddingBottom) / 2) + \")\");\n\n    var shapeSvg = shape(d3.select(this), bbox, node);\n    util.applyStyle(shapeSvg, node.style);\n\n    var shapeBBox = shapeSvg.node().getBBox();\n    node.width = shapeBBox.width;\n    node.height = shapeBBox.height;\n  });\n\n  util.applyTransition(svgNodes.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgNodes;\n}\n\n},{\"./d3\":7,\"./label/add-label\":18,\"./lodash\":21,\"./util\":27}],7:[function(require,module,exports){\n// Stub to get D3 either via NPM or from the global object\nmodule.exports = window.d3;\n\n},{}],8:[function(require,module,exports){\n/* global window */\n\nvar dagre;\n\nif (require) {\n  try {\n    dagre = require(\"dagre\");\n  } catch (e) {}\n}\n\nif (!dagre) {\n  dagre = window.dagre;\n}\n\nmodule.exports = dagre;\n\n},{\"dagre\":undefined}],9:[function(require,module,exports){\n/* global window */\n\nvar graphlib;\n\nif (require) {\n  try {\n    graphlib = require(\"graphlib\");\n  } catch (e) {}\n}\n\nif (!graphlib) {\n  graphlib = window.graphlib;\n}\n\nmodule.exports = graphlib;\n\n},{\"graphlib\":undefined}],10:[function(require,module,exports){\nmodule.exports = {\n  node: require(\"./intersect-node\"),\n  circle: require(\"./intersect-circle\"),\n  ellipse: require(\"./intersect-ellipse\"),\n  polygon: require(\"./intersect-polygon\"),\n  rect: require(\"./intersect-rect\")\n};\n\n},{\"./intersect-circle\":11,\"./intersect-ellipse\":12,\"./intersect-node\":14,\"./intersect-polygon\":15,\"./intersect-rect\":16}],11:[function(require,module,exports){\nvar intersectEllipse = require(\"./intersect-ellipse\");\n\nmodule.exports = intersectCircle;\n\nfunction intersectCircle(node, rx, point) {\n  return intersectEllipse(node, rx, rx, point);\n}\n\n},{\"./intersect-ellipse\":12}],12:[function(require,module,exports){\nmodule.exports = intersectEllipse;\n\nfunction intersectEllipse(node, rx, ry, point) {\n  // Formulae from: http://mathworld.wolfram.com/Ellipse-LineIntersection.html\n\n  var cx = node.x;\n  var cy = node.y;\n\n  var px = cx - point.x;\n  var py = cy - point.y;\n\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n\n  var dx = Math.abs(rx * ry * px / det);\n  if (point.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point.y < cy) {\n    dy = -dy;\n  }\n\n  return {x: cx + dx, y: cy + dy};\n}\n\n\n},{}],13:[function(require,module,exports){\nmodule.exports = intersectLine;\n\n/*\n * Returns the point at which two lines, p and q, intersect or returns\n * undefined if they do not intersect.\n */\nfunction intersectLine(p1, p2, q1, q2) {\n  // Algorithm from J. Avro, (ed.) Graphics Gems, No 2, Morgan Kaufmann, 1994,\n  // p7 and p473.\n\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2 , r3, r4;\n  var denom, offset, num;\n  var x, y;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is F(x,y) = a1 x +\n  // b1 y + c1 = 0.\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = (p2.x * p1.y) - (p1.x * p2.y);\n\n  // Compute r3 and r4.\n  r3 = ((a1 * q1.x) + (b1 * q1.y) + c1);\n  r4 = ((a1 * q2.x) + (b1 * q2.y) + c1);\n\n  // Check signs of r3 and r4. If both point 3 and point 4 lie on\n  // same side of line 1, the line segments do not intersect.\n  if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n    return /*DONT_INTERSECT*/;\n  }\n\n  // Compute a2, b2, c2 where line joining points 3 and 4 is G(x,y) = a2 x + b2 y + c2 = 0\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = (q2.x * q1.y) - (q1.x * q2.y);\n\n  // Compute r1 and r2\n  r1 = (a2 * p1.x) + (b2 * p1.y) + c2;\n  r2 = (a2 * p2.x) + (b2 * p2.y) + c2;\n\n  // Check signs of r1 and r2. If both point 1 and point 2 lie\n  // on same side of second line segment, the line segments do\n  // not intersect.\n  if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n    return /*DONT_INTERSECT*/;\n  }\n\n  // Line segments intersect: compute intersection point.\n  denom = (a1 * b2) - (a2 * b1);\n  if (denom === 0) {\n    return /*COLLINEAR*/;\n  }\n\n  offset = Math.abs(denom / 2);\n\n  // The denom/2 is to get rounding instead of truncating. It\n  // is added or subtracted to the numerator, depending upon the\n  // sign of the numerator.\n  num = (b1 * c2) - (b2 * c1);\n  x = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom);\n\n  num = (a2 * c1) - (a1 * c2);\n  y = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom);\n\n  return { x: x, y: y };\n}\n\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\n\n},{}],14:[function(require,module,exports){\nmodule.exports = intersectNode;\n\nfunction intersectNode(node, point) {\n  return node.intersect(point);\n}\n\n},{}],15:[function(require,module,exports){\nvar intersectLine = require(\"./intersect-line\");\n\nmodule.exports = intersectPolygon;\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n\n  var intersections = [];\n\n  var minX = Number.POSITIVE_INFINITY,\n      minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function(entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n\n  var left = x1 - node.width / 2 - minX;\n  var top =  y1 - node.height / 2 - minY;\n\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point,\n      {x: left + p1.x, y: top + p1.y}, {x: left + p2.x, y: top + p2.y});\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point.x,\n          pdy = p.y - point.y,\n          distp = Math.sqrt(pdx * pdx + pdy * pdy),\n\n          qdx = q.x - point.x,\n          qdy = q.y - point.y,\n          distq = Math.sqrt(qdx * qdx + qdy * qdy);\n\n      return (distp < distq) ? -1 : (distp === distq ? 0 : 1);\n    });\n  }\n  return intersections[0];\n}\n\n},{\"./intersect-line\":13}],16:[function(require,module,exports){\nmodule.exports = intersectRect;\n\nfunction intersectRect(node, point) {\n  var x = node.x;\n  var y = node.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n\n  return {x: x + sx, y: y + sy};\n}\n\n},{}],17:[function(require,module,exports){\nvar util = require(\"../util\");\n\nmodule.exports = addHtmlLabel;\n\nfunction addHtmlLabel(root, node) {\n  var fo = root\n    .append(\"foreignObject\")\n      .attr(\"width\", \"100000\");\n\n  var div = fo\n    .append(\"xhtml:div\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n\n  var label = node.label;\n  switch(typeof label) {\n    case \"function\":\n      div.insert(label);\n      break;\n    case \"object\":\n      // Currently we assume this is a DOM object.\n      div.insert(function() { return label; });\n      break;\n    default: div.html(label);\n  }\n\n  util.applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"inline-block\");\n  // Fix for firefox\n  div.style(\"white-space\", \"nowrap\");\n\n  var client = div[0][0].getBoundingClientRect();\n  fo\n    .attr(\"width\", client.width)\n    .attr(\"height\", client.height); \n\n  return fo;\n}\n\n},{\"../util\":27}],18:[function(require,module,exports){\nvar addTextLabel = require(\"./add-text-label\"),\n    addHtmlLabel = require(\"./add-html-label\"),\n    addSVGLabel  = require(\"./add-svg-label\");\n\nmodule.exports = addLabel;\n\nfunction addLabel(root, node, location) {\n  var label = node.label;\n  var labelSvg = root.append(\"g\");\n\n  // Allow the label to be a string, a function that returns a DOM element, or\n  // a DOM element itself.\n  if (node.labelType === \"svg\") {\n    addSVGLabel(labelSvg, node);\n  } else if (typeof label !== \"string\" || node.labelType === \"html\") {\n    addHtmlLabel(labelSvg, node);\n  } else {\n    addTextLabel(labelSvg, node);\n  }\n\n  var labelBBox = labelSvg.node().getBBox();\n  var y;\n  switch(location) {\n    case \"top\":\n      y = (-node.height / 2);\n      break;\n    case \"bottom\":\n      y = (node.height / 2) - labelBBox.height;\n      break;\n    default:\n      y = (-labelBBox.height / 2);\n  }\n  labelSvg.attr(\"transform\",\n                \"translate(\" + (-labelBBox.width / 2) + \",\" + y + \")\");\n\n  return labelSvg;\n}\n\n},{\"./add-html-label\":17,\"./add-svg-label\":19,\"./add-text-label\":20}],19:[function(require,module,exports){\nvar util = require(\"../util\");\n\nmodule.exports = addSVGLabel;\n\nfunction addSVGLabel(root, node) {\n  var domNode = root;\n\n  domNode.node().appendChild(node.label);\n\n  util.applyStyle(domNode, node.labelStyle);\n\n  return domNode;\n}\n\n},{\"../util\":27}],20:[function(require,module,exports){\nvar util = require(\"../util\");\n\nmodule.exports = addTextLabel;\n\n/*\n * Attaches a text label to the specified root. Handles escape sequences.\n */\nfunction addTextLabel(root, node) {\n  var domNode = root.append(\"text\");\n\n  var lines = processEscapeSequences(node.label).split(\"\\n\");\n  for (var i = 0; i < lines.length; i++) {\n    domNode\n      .append(\"tspan\")\n        .attr(\"xml:space\", \"preserve\")\n        .attr(\"dy\", \"1em\")\n        .attr(\"x\", \"1\")\n        .text(lines[i]);\n  }\n\n  util.applyStyle(domNode, node.labelStyle);\n\n  return domNode;\n}\n\nfunction processEscapeSequences(text) {\n  var newText = \"\",\n      escaped = false,\n      ch;\n  for (var i = 0; i < text.length; ++i) {\n    ch = text[i];\n    if (escaped) {\n      switch(ch) {\n        case \"n\": newText += \"\\n\"; break;\n        default: newText += ch;\n      }\n      escaped = false;\n    } else if (ch === \"\\\\\") {\n      escaped = true;\n    } else {\n      newText += ch;\n    }\n  }\n  return newText;\n}\n\n},{\"../util\":27}],21:[function(require,module,exports){\n/* global window */\n\nvar lodash;\n\nif (require) {\n  try {\n    lodash = require(\"lodash\");\n  } catch (e) {}\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n\n},{\"lodash\":undefined}],22:[function(require,module,exports){\n\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = positionClusters;\n\nfunction positionClusters(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(v) {\n    var node = g.node(v);\n    return \"translate(\" + node.x + \",\" + node.y + \")\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n      .style(\"opacity\", 1)\n      .attr(\"transform\", translate);\n\n  util.applyTransition(created.selectAll(\"rect\"), g)\n      .attr(\"width\", function(v) { return g.node(v).width; })\n      .attr(\"height\", function(v) { return g.node(v).height; })\n      .attr(\"x\", function(v) {\n        var node = g.node(v);\n        return -node.width / 2;\n      })\n      .attr(\"y\", function(v) {\n        var node = g.node(v);\n        return -node.height / 2;\n      });\n\n}\n\n},{\"./d3\":7,\"./util\":27}],23:[function(require,module,exports){\n\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\"),\n    _ = require(\"./lodash\");\n\nmodule.exports = positionEdgeLabels;\n\nfunction positionEdgeLabels(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(e) {\n    var edge = g.edge(e);\n    return _.has(edge, \"x\") ? \"translate(\" + edge.x + \",\" + edge.y + \")\" : \"\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n    .style(\"opacity\", 1)\n    .attr(\"transform\", translate);\n}\n\n},{\"./d3\":7,\"./lodash\":21,\"./util\":27}],24:[function(require,module,exports){\n\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = positionNodes;\n\nfunction positionNodes(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(v) {\n    var node = g.node(v);\n    return \"translate(\" + node.x + \",\" + node.y + \")\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n    .style(\"opacity\", 1)\n    .attr(\"transform\", translate);\n}\n\n},{\"./d3\":7,\"./util\":27}],25:[function(require,module,exports){\nvar _ = require(\"./lodash\"),\n    layout = require(\"./dagre\").layout;\n\nmodule.exports = render;\n\n// This design is based on http://bost.ocks.org/mike/chart/.\nfunction render() {\n  var createNodes = require(\"./create-nodes\"),\n      createClusters = require(\"./create-clusters\"),\n      createEdgeLabels = require(\"./create-edge-labels\"),\n      createEdgePaths = require(\"./create-edge-paths\"),\n      positionNodes = require(\"./position-nodes\"),\n      positionEdgeLabels = require(\"./position-edge-labels\"),\n      positionClusters = require(\"./position-clusters\"),\n      shapes = require(\"./shapes\"),\n      arrows = require(\"./arrows\");\n\n  var fn = function(svg, g) {\n    preProcessGraph(g);\n\n    var outputGroup = createOrSelectGroup(svg, \"output\"),\n        clustersGroup = createOrSelectGroup(outputGroup, \"clusters\"),\n        edgePathsGroup = createOrSelectGroup(outputGroup, \"edgePaths\"),\n        edgeLabels = createEdgeLabels(createOrSelectGroup(outputGroup, \"edgeLabels\"), g),\n        nodes = createNodes(createOrSelectGroup(outputGroup, \"nodes\"), g, shapes);\n\n    layout(g);\n\n    positionNodes(nodes, g);\n    positionEdgeLabels(edgeLabels, g);\n    createEdgePaths(edgePathsGroup, g, arrows);\n\n    var clusters = createClusters(clustersGroup, g);\n    positionClusters(clusters, g);\n\n    postProcessGraph(g);\n  };\n\n  fn.createNodes = function(value) {\n    if (!arguments.length) return createNodes;\n    createNodes = value;\n    return fn;\n  };\n\n  fn.createClusters = function(value) {\n    if (!arguments.length) return createClusters;\n    createClusters = value;\n    return fn;\n  };\n\n  fn.createEdgeLabels = function(value) {\n    if (!arguments.length) return createEdgeLabels;\n    createEdgeLabels = value;\n    return fn;\n  };\n\n  fn.createEdgePaths = function(value) {\n    if (!arguments.length) return createEdgePaths;\n    createEdgePaths = value;\n    return fn;\n  };\n\n  fn.shapes = function(value) {\n    if (!arguments.length) return shapes;\n    shapes = value;\n    return fn;\n  };\n\n  fn.arrows = function(value) {\n    if (!arguments.length) return arrows;\n    arrows = value;\n    return fn;\n  };\n\n  return fn;\n}\n\nvar NODE_DEFAULT_ATTRS = {\n  paddingLeft: 10,\n  paddingRight: 10,\n  paddingTop: 10,\n  paddingBottom: 10,\n  rx: 0,\n  ry: 0,\n  shape: \"rect\"\n};\n\nvar EDGE_DEFAULT_ATTRS = {\n  arrowhead: \"normal\",\n  lineInterpolate: \"linear\"\n};\n\nfunction preProcessGraph(g) {\n  g.nodes().forEach(function(v) {\n    var node = g.node(v);\n    if (!_.has(node, \"label\") && !g.children(v).length) { node.label = v; }\n\n    if (_.has(node, \"paddingX\")) {\n      _.defaults(node, {\n        paddingLeft: node.paddingX,\n        paddingRight: node.paddingX\n      });\n    }\n\n    if (_.has(node, \"paddingY\")) {\n      _.defaults(node, {\n        paddingTop: node.paddingY,\n        paddingBottom: node.paddingY\n      });\n    }\n\n    if (_.has(node, \"padding\")) {\n      _.defaults(node, {\n        paddingLeft: node.padding,\n        paddingRight: node.padding,\n        paddingTop: node.padding,\n        paddingBottom: node.padding\n      });\n    }\n\n    _.defaults(node, NODE_DEFAULT_ATTRS);\n\n    _.each([\"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\"], function(k) {\n      node[k] = Number(node[k]);\n    });\n\n    // Save dimensions for restore during post-processing\n    if (_.has(node, \"width\")) { node._prevWidth = node.width; }\n    if (_.has(node, \"height\")) { node._prevHeight = node.height; }\n  });\n\n  g.edges().forEach(function(e) {\n    var edge = g.edge(e);\n    if (!_.has(edge, \"label\")) { edge.label = \"\"; }\n    _.defaults(edge, EDGE_DEFAULT_ATTRS);\n  });\n}\n\nfunction postProcessGraph(g) {\n  _.each(g.nodes(), function(v) {\n    var node = g.node(v);\n\n    // Restore original dimensions\n    if (_.has(node, \"_prevWidth\")) {\n      node.width = node._prevWidth;\n    } else {\n      delete node.width;\n    }\n\n    if (_.has(node, \"_prevHeight\")) {\n      node.height = node._prevHeight;\n    } else {\n      delete node.height;\n    }\n\n    delete node._prevWidth;\n    delete node._prevHeight;\n  });\n}\n\nfunction createOrSelectGroup(root, name) {\n  var selection = root.select(\"g.\" + name);\n  if (selection.empty()) {\n    selection = root.append(\"g\").attr(\"class\", name);\n  }\n  return selection;\n}\n\n},{\"./arrows\":2,\"./create-clusters\":3,\"./create-edge-labels\":4,\"./create-edge-paths\":5,\"./create-nodes\":6,\"./dagre\":8,\"./lodash\":21,\"./position-clusters\":22,\"./position-edge-labels\":23,\"./position-nodes\":24,\"./shapes\":26}],26:[function(require,module,exports){\n\"use strict\";\n\nvar intersectRect = require(\"./intersect/intersect-rect\"),\n    intersectEllipse = require(\"./intersect/intersect-ellipse\"),\n    intersectCircle = require(\"./intersect/intersect-circle\"),\n    intersectPolygon = require(\"./intersect/intersect-polygon\");\n\nmodule.exports = {\n  rect: rect,\n  ellipse: ellipse,\n  circle: circle,\n  diamond: diamond\n};\n\nfunction rect(parent, bbox, node) {\n  var shapeSvg = parent.insert(\"rect\", \":first-child\")\n        .attr(\"rx\", node.rx)\n        .attr(\"ry\", node.ry)\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"width\", bbox.width)\n        .attr(\"height\", bbox.height);\n\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction ellipse(parent, bbox, node) {\n  var rx = bbox.width / 2,\n      ry = bbox.height / 2,\n      shapeSvg = parent.insert(\"ellipse\", \":first-child\")\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"rx\", rx)\n        .attr(\"ry\", ry);\n\n  node.intersect = function(point) {\n    return intersectEllipse(node, rx, ry, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction circle(parent, bbox, node) {\n  var r = Math.max(bbox.width, bbox.height) / 2,\n      shapeSvg = parent.insert(\"circle\", \":first-child\")\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"r\", r);\n\n  node.intersect = function(point) {\n    return intersectCircle(node, r, point);\n  };\n\n  return shapeSvg;\n}\n\n// Circumscribe an ellipse for the bounding box with a diamond shape. I derived\n// the function to calculate the diamond shape from:\n// http://mathforum.org/kb/message.jspa?messageID=3750236\nfunction diamond(parent, bbox, node) {\n  var w = (bbox.width * Math.SQRT2) / 2,\n      h = (bbox.height * Math.SQRT2) / 2,\n      points = [\n        { x:  0, y: -h },\n        { x: -w, y:  0 },\n        { x:  0, y:  h },\n        { x:  w, y:  0 }\n      ],\n      shapeSvg = parent.insert(\"polygon\", \":first-child\")\n        .attr(\"points\", points.map(function(p) { return p.x + \",\" + p.y; }).join(\" \"));\n\n  node.intersect = function(p) {\n    return intersectPolygon(node, points, p);\n  };\n\n  return shapeSvg;\n}\n\n},{\"./intersect/intersect-circle\":11,\"./intersect/intersect-ellipse\":12,\"./intersect/intersect-polygon\":15,\"./intersect/intersect-rect\":16}],27:[function(require,module,exports){\nvar _ = require(\"./lodash\");\n\n// Public utility functions\nmodule.exports = {\n  isSubgraph: isSubgraph,\n  edgeToId: edgeToId,\n  applyStyle: applyStyle,\n  applyClass: applyClass,\n  applyTransition: applyTransition\n};\n\n/*\n * Returns true if the specified node in the graph is a subgraph node. A\n * subgraph node is one that contains other nodes.\n */\nfunction isSubgraph(g, v) {\n  return !!g.children(v).length;\n}\n\nfunction edgeToId(e) {\n  return escapeId(e.v) + \":\" + escapeId(e.w) + \":\" + escapeId(e.name);\n}\n\nvar ID_DELIM = /:/g;\nfunction escapeId(str) {\n  return str ? String(str).replace(ID_DELIM, \"\\\\:\") : \"\";\n}\n\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n\nfunction applyClass(dom, classFn, otherClasses) {\n  if (classFn) {\n    dom\n      .attr(\"class\", classFn)\n      .attr(\"class\", otherClasses + \" \" + dom.attr(\"class\"));\n  }\n}\n\nfunction applyTransition(selection, g) {\n  var graph = g.graph();\n\n  if (_.isPlainObject(graph)) {\n    var transition = graph.transition;\n    if (_.isFunction(transition)) {\n      return transition(selection);\n    }\n  }\n\n  return selection;\n}\n\n},{\"./lodash\":21}],28:[function(require,module,exports){\nmodule.exports = \"0.4.18-pre\";\n\n},{}]},{},[1])(1)\n});\n\n","var util = require(\"./util\");\n\nmodule.exports = {\n  \"default\": normal,\n  \"normal\": normal,\n  \"vee\": vee,\n  \"undirected\": undirected\n};\n\nfunction normal(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n\nfunction vee(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 0 L 10 5 L 0 10 L 4 5 z\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n\nfunction undirected(parent, id, edge, type) {\n  var marker = parent.append(\"marker\")\n    .attr(\"id\", id)\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 9)\n    .attr(\"refY\", 5)\n    .attr(\"markerUnits\", \"strokeWidth\")\n    .attr(\"markerWidth\", 8)\n    .attr(\"markerHeight\", 6)\n    .attr(\"orient\", \"auto\");\n\n  var path = marker.append(\"path\")\n    .attr(\"d\", \"M 0 5 L 10 5\")\n    .style(\"stroke-width\", 1)\n    .style(\"stroke-dasharray\", \"1,0\");\n  util.applyStyle(path, edge[type + \"Style\"]);\n  if (edge[type + \"Class\"]) {\n    path.attr(\"class\", edge[type + \"Class\"]);\n  }\n}\n","var util = require(\"./util\"),\n    addLabel = require(\"./label/add-label\");\n\nmodule.exports = createClusters;\n\nfunction createClusters(selection, g) {\n  var clusters = g.nodes().filter(function(v) { return util.isSubgraph(g, v); }),\n      svgClusters = selection.selectAll(\"g.cluster\")\n        .data(clusters, function(v) { return v; });\n\n  svgClusters.selectAll(\"*\").remove();\n  svgClusters.enter()\n    .append(\"g\")\n      .attr(\"class\", \"cluster\")\n      .attr(\"id\",function(v){\n          var node = g.node(v);\n          return node.id;\n      })\n      .style(\"opacity\", 0);\n\n  util.applyTransition(svgClusters, g)\n    .style(\"opacity\", 1);\n\n  svgClusters.each(function(v) {\n    var node = g.node(v),\n        thisGroup = d3.select(this);\n    d3.select(this).append(\"rect\");\n    var labelGroup = thisGroup.append(\"g\").attr(\"class\", \"label\");\n    addLabel(labelGroup, node, node.clusterLabelPos);\n  });\n\n  svgClusters.selectAll(\"rect\").each(function(c) {\n    var node = g.node(c);\n    var domCluster = d3.select(this);\n    util.applyStyle(domCluster, node.style);\n  });\n\n  util.applyTransition(svgClusters.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgClusters;\n}\n","\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    addLabel = require(\"./label/add-label\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = createEdgeLabels;\n\nfunction createEdgeLabels(selection, g) {\n  var svgEdgeLabels = selection.selectAll(\"g.edgeLabel\")\n    .data(g.edges(), function(e) { return util.edgeToId(e); })\n    .classed(\"update\", true);\n\n  svgEdgeLabels.selectAll(\"*\").remove();\n  svgEdgeLabels.enter()\n    .append(\"g\")\n      .classed(\"edgeLabel\", true)\n      .style(\"opacity\", 0);\n  svgEdgeLabels.each(function(e) {\n    var edge = g.edge(e),\n        label = addLabel(d3.select(this), g.edge(e), 0, 0).classed(\"label\", true),\n        bbox = label.node().getBBox();\n\n    if (edge.labelId) { label.attr(\"id\", edge.labelId); }\n    if (!_.has(edge, \"width\")) { edge.width = bbox.width; }\n    if (!_.has(edge, \"height\")) { edge.height = bbox.height; }\n  });\n\n  util.applyTransition(svgEdgeLabels.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgEdgeLabels;\n}\n","\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    intersectNode = require(\"./intersect/intersect-node\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\nmodule.exports = createEdgePaths;\n\nfunction createEdgePaths(selection, g, arrows) {\n  var svgPaths = selection.selectAll(\"g.edgePath\")\n    .data(g.edges(), function(e) { return util.edgeToId(e); })\n    .classed(\"update\", true);\n\n  // Update the first point in the edge so it is shown in the correct category.\n  adjustEdgePositionsForCategories(g);\n\n  enter(svgPaths, g);\n  exit(svgPaths, g);\n\n  util.applyTransition(svgPaths, g)\n    .style(\"opacity\", 1);\n\n  // Save DOM element in the path group, and set ID and class\n  svgPaths.each(function(e) {\n    var domEdge = d3.select(this);\n    var edge = g.edge(e);\n    edge.elem = this;\n\n    if (edge.id) {\n      domEdge.attr(\"id\", edge.id);\n    }\n\n    util.applyClass(domEdge, edge[\"class\"],\n      (domEdge.classed(\"update\") ? \"update \" : \"\") + \"edgePath\");\n  });\n\n  svgPaths.selectAll(\"path.path\")\n    .each(function(e) {\n      var edge = g.edge(e);\n      edge.arrowheadId = _.uniqueId(\"arrowhead\");\n\n      var domEdge = d3.select(this)\n        .attr(\"marker-end\", function() {\n            return \"url(\" + makeFragmentRef(location.href, edge.arrowheadId) + \")\";\n        })\n        .style(\"fill\", \"none\");\n\n      util.applyTransition(domEdge, g)\n        .attr(\"d\", function(e) { return calcPoints(g, e); });\n\n      util.applyStyle(domEdge, edge.style);\n    });\n\n  svgPaths.selectAll(\"defs *\").remove();\n  svgPaths.selectAll(\"defs\")\n    .each(function(e) {\n      var edge = g.edge(e),\n          arrowhead = arrows[edge.arrowhead];\n      arrowhead(d3.select(this), edge.arrowheadId, edge, \"arrowhead\");\n    });\n\n  return svgPaths;\n}\n\nfunction adjustEdgePositionsForCategories(g) {\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e),\n        source = g.node(e.v);\n    // Only perform this adjustment if the edge & source node has the required\n    // properties.\n    if (!edge.hasOwnProperty(\"categoryIndex\")\n        || !source.hasOwnProperty(\"numberOfCategories\")\n        || source.numberOfCategories === 0) {\n      return;\n    }\n\n    repositionFirstPointInEdge(g, e);\n\n    if (e.v === e.w) {\n      // Recursive edge.\n      redrawLoop(g, edge, source);\n    }\n    else if (g.graph().hasOwnProperty(\"ranksep\") && edge.points.length > 2) {\n      // Make sure the second point in the edge is at least ranksep from the\n      // source node. This should help make overlapping edges from the same node\n      // easier to follow.\n      edge.points[1].y = Math.max(edge.points[1].y, edge.points[0].y\n        + g.graph().ranksep - 20);\n    }\n  });\n}\n\nfunction repositionFirstPointInEdge(g, e) {\n  var edge = g.edge(e),\n      source = g.node(e.v);\n  var categoriesPaddingLeft = 0;\n  if (g.graph().hasOwnProperty(\"categoriesPaddingLeft\")) {\n    categoriesPaddingLeft = g.graph().categoriesPaddingLeft;\n  }\n\n  var categoriesPaddingRight = 0;\n  if (g.graph().hasOwnProperty(\"categoriesPaddingRight\")) {\n    categoriesPaddingRight = g.graph().categoriesPaddingRight;\n  }\n\n  var edgesInCategory = g.outEdges(e.v).filter(inSameCategory(g, e));\n  // Ensure edges in same category never cross.\n  edgesInCategory.sort(sortEdgesBySinkPosition(g));\n  var categoryIndex = edgesInCategory.indexOf(e);\n  var pctPlacement = (categoryIndex + 1)/(edgesInCategory.length + 1);\n  var categoriesWidth = source.width - categoriesPaddingLeft\n    - categoriesPaddingRight;\n  var categoryWidth = categoriesWidth/source.numberOfCategories;\n  var nodeLeftX = source.x - source.width/2;\n\n  // Assign a new x value for the first point so it is in the correct category.\n  edge.points[0].x = nodeLeftX + categoriesPaddingLeft\n    + categoryWidth * edge.categoryIndex + pctPlacement * categoryWidth;\n  edge.points[0].y = source.y + source.height/2;\n}\n\nfunction redrawLoop(g, edge, source) {\n  var recursiveEdgePadding = 50;\n  if (g.graph().hasOwnProperty(\"recursivesep\")) {\n    recursiveEdgePadding = g.graph().recursivesep;\n  }\n\n  var p0 = edge.points[0];\n  var x1 = p0.x, y1 = p0.y + recursiveEdgePadding;\n  var x2, y2 = y1;\n  var x4, y4 = source.y;\n  if (p0.x < source.x && source.x - source.width/2 - recursiveEdgePadding > 0) {\n    // Wrap around left of node.\n    x2 = source.x - source.width/2 - recursiveEdgePadding;\n    x4 = x2 + recursiveEdgePadding;\n  } else {\n  // Wrap around right of node.\n    x2 = source.x + source.width/2 + recursiveEdgePadding;\n    x4 = x2 - recursiveEdgePadding;\n  }\n  var x3 = x2, y3 = y4;\n\n  edge.points = [edge.points[0], {x: x1, y: y1}, {x: x2, y: y2},\n    {x: x3, y: y3}, {x: x4, y: y4}];\n}\n\nfunction inSameCategory(g, e1) {\n  return function(e2) {\n    return g.edge(e1).categoryIndex === g.edge(e2).categoryIndex;\n  };\n}\n\nfunction sortEdgesBySinkPosition(g) {\n  return function(edge1, edge2) {\n    return g.node(edge1.w).x - g.node(edge2.w).x;\n  };\n}\n\nfunction makeFragmentRef(url, fragmentId) {\n  var baseUrl = url.split(\"#\")[0];\n  return baseUrl + \"#\" + fragmentId;\n}\n\nfunction calcPoints(g, e) {\n  var edge = g.edge(e),\n      tail = g.node(e.v),\n      head = g.node(e.w);\n  var points;\n  if (edge.hasOwnProperty(\"categoryIndex\")\n      && tail.hasOwnProperty(\"numberOfCategories\")) {\n    points = edge.points.slice(0, edge.points.length - 1);\n  } else {\n    points = edge.points.slice(1, edge.points.length - 1);\n    points.unshift(intersectNode(tail, points[0]));\n  }\n  points.push(intersectNode(head, points[points.length - 1]));\n\n  return createLine(edge, points);\n}\n\nfunction createLine(edge, points) {\n  var line = d3.svg.line()\n    .x(function(d) { return d.x; })\n    .y(function(d) { return d.y; });\n\n  if (_.has(edge, \"lineInterpolate\")) {\n    line.interpolate(edge.lineInterpolate);\n  }\n\n  if (_.has(edge, \"lineTension\")) {\n    line.tension(Number(edge.lineTension));\n  }\n\n  return line(points);\n}\n\nfunction getCoords(elem) {\n  var bbox = elem.getBBox(),\n      matrix = elem.ownerSVGElement.getScreenCTM()\n        .inverse()\n        .multiply(elem.getScreenCTM())\n        .translate(bbox.width / 2, bbox.height / 2);\n  return { x: matrix.e, y: matrix.f };\n}\n\nfunction enter(svgPaths, g) {\n  var svgPathsEnter = svgPaths.enter()\n    .append(\"g\")\n      .attr(\"class\", \"edgePath\")\n      .style(\"opacity\", 0);\n  svgPathsEnter.append(\"path\")\n    .attr(\"class\", \"path\")\n    .attr(\"d\", function(e) {\n      var edge = g.edge(e),\n          sourceElem = g.node(e.v).elem,\n          points = _.range(edge.points.length).map(function() { return getCoords(sourceElem); });\n      return createLine(edge, points);\n    });\n  svgPathsEnter.append(\"defs\");\n}\n\nfunction exit(svgPaths, g) {\n  var svgPathExit = svgPaths.exit();\n  util.applyTransition(svgPathExit, g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  util.applyTransition(svgPathExit.select(\"path.path\"), g)\n    .attr(\"d\", function(e) {\n      var source = g.node(e.v);\n\n      if (source) {\n        var points = _.range(this.getTotalLength()).map(function() { return source; });\n        return createLine({}, points);\n      } else {\n        return d3.select(this).attr(\"d\");\n      }\n    });\n}\n","\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    addLabel = require(\"./label/add-label\"),\n    util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = createNodes;\n\nfunction createNodes(selection, g, shapes) {\n  var simpleNodes = g.nodes().filter(function(v) { return !util.isSubgraph(g, v); });\n  var svgNodes = selection.selectAll(\"g.node\")\n    .data(simpleNodes, function(v) { return v; })\n    .classed(\"update\", true);\n\n  svgNodes.selectAll(\"*\").remove();\n  svgNodes.enter()\n    .append(\"g\")\n      .attr(\"class\", \"node\")\n      .style(\"opacity\", 0);\n  svgNodes.each(function(v) {\n    var node = g.node(v),\n        thisGroup = d3.select(this),\n        labelGroup = thisGroup.append(\"g\").attr(\"class\", \"label\"),\n        labelDom = addLabel(labelGroup, node),\n        shape = shapes[node.shape],\n        bbox = _.pick(labelDom.node().getBBox(), \"width\", \"height\");\n\n    node.elem = this;\n\n    if (node.id) { thisGroup.attr(\"id\", node.id); }\n    if (node.labelId) { labelGroup.attr(\"id\", node.labelId); }\n    util.applyClass(thisGroup, node[\"class\"],\n      (thisGroup.classed(\"update\") ? \"update \" : \"\") + \"node\");\n\n    if (_.has(node, \"width\")) { bbox.width = node.width; }\n    if (_.has(node, \"height\")) { bbox.height = node.height; }\n\n    bbox.width += node.paddingLeft + node.paddingRight;\n    bbox.height += node.paddingTop + node.paddingBottom;\n    labelGroup.attr(\"transform\", \"translate(\" +\n      ((node.paddingLeft - node.paddingRight) / 2) + \",\" +\n      ((node.paddingTop - node.paddingBottom) / 2) + \")\");\n\n    var shapeSvg = shape(d3.select(this), bbox, node);\n    util.applyStyle(shapeSvg, node.style);\n\n    var shapeBBox = shapeSvg.node().getBBox();\n    node.width = shapeBBox.width;\n    node.height = shapeBBox.height;\n  });\n\n  util.applyTransition(svgNodes.exit(), g)\n    .style(\"opacity\", 0)\n    .remove();\n\n  return svgNodes;\n}\n","// Stub to get D3 either via NPM or from the global object\nmodule.exports = window.d3;\n","/* global window */\n\nvar dagre;\n\nif (require) {\n  try {\n    dagre = require(\"dagre\");\n  } catch (e) {}\n}\n\nif (!dagre) {\n  dagre = window.dagre;\n}\n\nmodule.exports = dagre;\n","/* global window */\n\nvar graphlib;\n\nif (require) {\n  try {\n    graphlib = require(\"graphlib\");\n  } catch (e) {}\n}\n\nif (!graphlib) {\n  graphlib = window.graphlib;\n}\n\nmodule.exports = graphlib;\n","module.exports = {\n  node: require(\"./intersect-node\"),\n  circle: require(\"./intersect-circle\"),\n  ellipse: require(\"./intersect-ellipse\"),\n  polygon: require(\"./intersect-polygon\"),\n  rect: require(\"./intersect-rect\")\n};\n","var intersectEllipse = require(\"./intersect-ellipse\");\n\nmodule.exports = intersectCircle;\n\nfunction intersectCircle(node, rx, point) {\n  return intersectEllipse(node, rx, rx, point);\n}\n","module.exports = intersectEllipse;\n\nfunction intersectEllipse(node, rx, ry, point) {\n  // Formulae from: http://mathworld.wolfram.com/Ellipse-LineIntersection.html\n\n  var cx = node.x;\n  var cy = node.y;\n\n  var px = cx - point.x;\n  var py = cy - point.y;\n\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n\n  var dx = Math.abs(rx * ry * px / det);\n  if (point.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point.y < cy) {\n    dy = -dy;\n  }\n\n  return {x: cx + dx, y: cy + dy};\n}\n\n","module.exports = intersectLine;\n\n/*\n * Returns the point at which two lines, p and q, intersect or returns\n * undefined if they do not intersect.\n */\nfunction intersectLine(p1, p2, q1, q2) {\n  // Algorithm from J. Avro, (ed.) Graphics Gems, No 2, Morgan Kaufmann, 1994,\n  // p7 and p473.\n\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2 , r3, r4;\n  var denom, offset, num;\n  var x, y;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is F(x,y) = a1 x +\n  // b1 y + c1 = 0.\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = (p2.x * p1.y) - (p1.x * p2.y);\n\n  // Compute r3 and r4.\n  r3 = ((a1 * q1.x) + (b1 * q1.y) + c1);\n  r4 = ((a1 * q2.x) + (b1 * q2.y) + c1);\n\n  // Check signs of r3 and r4. If both point 3 and point 4 lie on\n  // same side of line 1, the line segments do not intersect.\n  if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n    return /*DONT_INTERSECT*/;\n  }\n\n  // Compute a2, b2, c2 where line joining points 3 and 4 is G(x,y) = a2 x + b2 y + c2 = 0\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = (q2.x * q1.y) - (q1.x * q2.y);\n\n  // Compute r1 and r2\n  r1 = (a2 * p1.x) + (b2 * p1.y) + c2;\n  r2 = (a2 * p2.x) + (b2 * p2.y) + c2;\n\n  // Check signs of r1 and r2. If both point 1 and point 2 lie\n  // on same side of second line segment, the line segments do\n  // not intersect.\n  if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n    return /*DONT_INTERSECT*/;\n  }\n\n  // Line segments intersect: compute intersection point.\n  denom = (a1 * b2) - (a2 * b1);\n  if (denom === 0) {\n    return /*COLLINEAR*/;\n  }\n\n  offset = Math.abs(denom / 2);\n\n  // The denom/2 is to get rounding instead of truncating. It\n  // is added or subtracted to the numerator, depending upon the\n  // sign of the numerator.\n  num = (b1 * c2) - (b2 * c1);\n  x = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom);\n\n  num = (a2 * c1) - (a1 * c2);\n  y = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom);\n\n  return { x: x, y: y };\n}\n\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\n","module.exports = intersectNode;\n\nfunction intersectNode(node, point) {\n  return node.intersect(point);\n}\n","var intersectLine = require(\"./intersect-line\");\n\nmodule.exports = intersectPolygon;\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n\n  var intersections = [];\n\n  var minX = Number.POSITIVE_INFINITY,\n      minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function(entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n\n  var left = x1 - node.width / 2 - minX;\n  var top =  y1 - node.height / 2 - minY;\n\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point,\n      {x: left + p1.x, y: top + p1.y}, {x: left + p2.x, y: top + p2.y});\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point.x,\n          pdy = p.y - point.y,\n          distp = Math.sqrt(pdx * pdx + pdy * pdy),\n\n          qdx = q.x - point.x,\n          qdy = q.y - point.y,\n          distq = Math.sqrt(qdx * qdx + qdy * qdy);\n\n      return (distp < distq) ? -1 : (distp === distq ? 0 : 1);\n    });\n  }\n  return intersections[0];\n}\n","module.exports = intersectRect;\n\nfunction intersectRect(node, point) {\n  var x = node.x;\n  var y = node.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n\n  return {x: x + sx, y: y + sy};\n}\n","var util = require(\"../util\");\n\nmodule.exports = addHtmlLabel;\n\nfunction addHtmlLabel(root, node) {\n  var fo = root\n    .append(\"foreignObject\")\n      .attr(\"width\", \"100000\");\n\n  var div = fo\n    .append(\"xhtml:div\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n\n  var label = node.label;\n  switch(typeof label) {\n    case \"function\":\n      div.insert(label);\n      break;\n    case \"object\":\n      // Currently we assume this is a DOM object.\n      div.insert(function() { return label; });\n      break;\n    default: div.html(label);\n  }\n\n  util.applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"inline-block\");\n  // Fix for firefox\n  div.style(\"white-space\", \"nowrap\");\n\n  var client = div[0][0].getBoundingClientRect();\n  fo\n    .attr(\"width\", client.width)\n    .attr(\"height\", client.height); \n\n  return fo;\n}\n","var addTextLabel = require(\"./add-text-label\"),\n    addHtmlLabel = require(\"./add-html-label\"),\n    addSVGLabel  = require(\"./add-svg-label\");\n\nmodule.exports = addLabel;\n\nfunction addLabel(root, node, location) {\n  var label = node.label;\n  var labelSvg = root.append(\"g\");\n\n  // Allow the label to be a string, a function that returns a DOM element, or\n  // a DOM element itself.\n  if (node.labelType === \"svg\") {\n    addSVGLabel(labelSvg, node);\n  } else if (typeof label !== \"string\" || node.labelType === \"html\") {\n    addHtmlLabel(labelSvg, node);\n  } else {\n    addTextLabel(labelSvg, node);\n  }\n\n  var labelBBox = labelSvg.node().getBBox();\n  var y;\n  switch(location) {\n    case \"top\":\n      y = (-node.height / 2);\n      break;\n    case \"bottom\":\n      y = (node.height / 2) - labelBBox.height;\n      break;\n    default:\n      y = (-labelBBox.height / 2);\n  }\n  labelSvg.attr(\"transform\",\n                \"translate(\" + (-labelBBox.width / 2) + \",\" + y + \")\");\n\n  return labelSvg;\n}\n","var util = require(\"../util\");\n\nmodule.exports = addSVGLabel;\n\nfunction addSVGLabel(root, node) {\n  var domNode = root;\n\n  domNode.node().appendChild(node.label);\n\n  util.applyStyle(domNode, node.labelStyle);\n\n  return domNode;\n}\n","var util = require(\"../util\");\n\nmodule.exports = addTextLabel;\n\n/*\n * Attaches a text label to the specified root. Handles escape sequences.\n */\nfunction addTextLabel(root, node) {\n  var domNode = root.append(\"text\");\n\n  var lines = processEscapeSequences(node.label).split(\"\\n\");\n  for (var i = 0; i < lines.length; i++) {\n    domNode\n      .append(\"tspan\")\n        .attr(\"xml:space\", \"preserve\")\n        .attr(\"dy\", \"1em\")\n        .attr(\"x\", \"1\")\n        .text(lines[i]);\n  }\n\n  util.applyStyle(domNode, node.labelStyle);\n\n  return domNode;\n}\n\nfunction processEscapeSequences(text) {\n  var newText = \"\",\n      escaped = false,\n      ch;\n  for (var i = 0; i < text.length; ++i) {\n    ch = text[i];\n    if (escaped) {\n      switch(ch) {\n        case \"n\": newText += \"\\n\"; break;\n        default: newText += ch;\n      }\n      escaped = false;\n    } else if (ch === \"\\\\\") {\n      escaped = true;\n    } else {\n      newText += ch;\n    }\n  }\n  return newText;\n}\n","/* global window */\n\nvar lodash;\n\nif (require) {\n  try {\n    lodash = require(\"lodash\");\n  } catch (e) {}\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n","\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = positionClusters;\n\nfunction positionClusters(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(v) {\n    var node = g.node(v);\n    return \"translate(\" + node.x + \",\" + node.y + \")\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n      .style(\"opacity\", 1)\n      .attr(\"transform\", translate);\n\n  util.applyTransition(created.selectAll(\"rect\"), g)\n      .attr(\"width\", function(v) { return g.node(v).width; })\n      .attr(\"height\", function(v) { return g.node(v).height; })\n      .attr(\"x\", function(v) {\n        var node = g.node(v);\n        return -node.width / 2;\n      })\n      .attr(\"y\", function(v) {\n        var node = g.node(v);\n        return -node.height / 2;\n      });\n\n}\n","\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\"),\n    _ = require(\"./lodash\");\n\nmodule.exports = positionEdgeLabels;\n\nfunction positionEdgeLabels(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(e) {\n    var edge = g.edge(e);\n    return _.has(edge, \"x\") ? \"translate(\" + edge.x + \",\" + edge.y + \")\" : \"\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n    .style(\"opacity\", 1)\n    .attr(\"transform\", translate);\n}\n","\"use strict\";\n\nvar util = require(\"./util\"),\n    d3 = require(\"./d3\");\n\nmodule.exports = positionNodes;\n\nfunction positionNodes(selection, g) {\n  var created = selection.filter(function() { return !d3.select(this).classed(\"update\"); });\n\n  function translate(v) {\n    var node = g.node(v);\n    return \"translate(\" + node.x + \",\" + node.y + \")\";\n  }\n\n  created.attr(\"transform\", translate);\n\n  util.applyTransition(selection, g)\n    .style(\"opacity\", 1)\n    .attr(\"transform\", translate);\n}\n","var _ = require(\"./lodash\"),\n    layout = require(\"./dagre\").layout;\n\nmodule.exports = render;\n\n// This design is based on http://bost.ocks.org/mike/chart/.\nfunction render() {\n  var createNodes = require(\"./create-nodes\"),\n      createClusters = require(\"./create-clusters\"),\n      createEdgeLabels = require(\"./create-edge-labels\"),\n      createEdgePaths = require(\"./create-edge-paths\"),\n      positionNodes = require(\"./position-nodes\"),\n      positionEdgeLabels = require(\"./position-edge-labels\"),\n      positionClusters = require(\"./position-clusters\"),\n      shapes = require(\"./shapes\"),\n      arrows = require(\"./arrows\");\n\n  var fn = function(svg, g) {\n    preProcessGraph(g);\n\n    var outputGroup = createOrSelectGroup(svg, \"output\"),\n        clustersGroup = createOrSelectGroup(outputGroup, \"clusters\"),\n        edgePathsGroup = createOrSelectGroup(outputGroup, \"edgePaths\"),\n        edgeLabels = createEdgeLabels(createOrSelectGroup(outputGroup, \"edgeLabels\"), g),\n        nodes = createNodes(createOrSelectGroup(outputGroup, \"nodes\"), g, shapes);\n\n    layout(g);\n\n    positionNodes(nodes, g);\n    positionEdgeLabels(edgeLabels, g);\n    createEdgePaths(edgePathsGroup, g, arrows);\n\n    var clusters = createClusters(clustersGroup, g);\n    positionClusters(clusters, g);\n\n    postProcessGraph(g);\n  };\n\n  fn.createNodes = function(value) {\n    if (!arguments.length) return createNodes;\n    createNodes = value;\n    return fn;\n  };\n\n  fn.createClusters = function(value) {\n    if (!arguments.length) return createClusters;\n    createClusters = value;\n    return fn;\n  };\n\n  fn.createEdgeLabels = function(value) {\n    if (!arguments.length) return createEdgeLabels;\n    createEdgeLabels = value;\n    return fn;\n  };\n\n  fn.createEdgePaths = function(value) {\n    if (!arguments.length) return createEdgePaths;\n    createEdgePaths = value;\n    return fn;\n  };\n\n  fn.shapes = function(value) {\n    if (!arguments.length) return shapes;\n    shapes = value;\n    return fn;\n  };\n\n  fn.arrows = function(value) {\n    if (!arguments.length) return arrows;\n    arrows = value;\n    return fn;\n  };\n\n  return fn;\n}\n\nvar NODE_DEFAULT_ATTRS = {\n  paddingLeft: 10,\n  paddingRight: 10,\n  paddingTop: 10,\n  paddingBottom: 10,\n  rx: 0,\n  ry: 0,\n  shape: \"rect\"\n};\n\nvar EDGE_DEFAULT_ATTRS = {\n  arrowhead: \"normal\",\n  lineInterpolate: \"linear\"\n};\n\nfunction preProcessGraph(g) {\n  g.nodes().forEach(function(v) {\n    var node = g.node(v);\n    if (!_.has(node, \"label\") && !g.children(v).length) { node.label = v; }\n\n    if (_.has(node, \"paddingX\")) {\n      _.defaults(node, {\n        paddingLeft: node.paddingX,\n        paddingRight: node.paddingX\n      });\n    }\n\n    if (_.has(node, \"paddingY\")) {\n      _.defaults(node, {\n        paddingTop: node.paddingY,\n        paddingBottom: node.paddingY\n      });\n    }\n\n    if (_.has(node, \"padding\")) {\n      _.defaults(node, {\n        paddingLeft: node.padding,\n        paddingRight: node.padding,\n        paddingTop: node.padding,\n        paddingBottom: node.padding\n      });\n    }\n\n    _.defaults(node, NODE_DEFAULT_ATTRS);\n\n    _.each([\"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\"], function(k) {\n      node[k] = Number(node[k]);\n    });\n\n    // Save dimensions for restore during post-processing\n    if (_.has(node, \"width\")) { node._prevWidth = node.width; }\n    if (_.has(node, \"height\")) { node._prevHeight = node.height; }\n  });\n\n  g.edges().forEach(function(e) {\n    var edge = g.edge(e);\n    if (!_.has(edge, \"label\")) { edge.label = \"\"; }\n    _.defaults(edge, EDGE_DEFAULT_ATTRS);\n  });\n}\n\nfunction postProcessGraph(g) {\n  _.each(g.nodes(), function(v) {\n    var node = g.node(v);\n\n    // Restore original dimensions\n    if (_.has(node, \"_prevWidth\")) {\n      node.width = node._prevWidth;\n    } else {\n      delete node.width;\n    }\n\n    if (_.has(node, \"_prevHeight\")) {\n      node.height = node._prevHeight;\n    } else {\n      delete node.height;\n    }\n\n    delete node._prevWidth;\n    delete node._prevHeight;\n  });\n}\n\nfunction createOrSelectGroup(root, name) {\n  var selection = root.select(\"g.\" + name);\n  if (selection.empty()) {\n    selection = root.append(\"g\").attr(\"class\", name);\n  }\n  return selection;\n}\n","\"use strict\";\n\nvar intersectRect = require(\"./intersect/intersect-rect\"),\n    intersectEllipse = require(\"./intersect/intersect-ellipse\"),\n    intersectCircle = require(\"./intersect/intersect-circle\"),\n    intersectPolygon = require(\"./intersect/intersect-polygon\");\n\nmodule.exports = {\n  rect: rect,\n  ellipse: ellipse,\n  circle: circle,\n  diamond: diamond\n};\n\nfunction rect(parent, bbox, node) {\n  var shapeSvg = parent.insert(\"rect\", \":first-child\")\n        .attr(\"rx\", node.rx)\n        .attr(\"ry\", node.ry)\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"width\", bbox.width)\n        .attr(\"height\", bbox.height);\n\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction ellipse(parent, bbox, node) {\n  var rx = bbox.width / 2,\n      ry = bbox.height / 2,\n      shapeSvg = parent.insert(\"ellipse\", \":first-child\")\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"rx\", rx)\n        .attr(\"ry\", ry);\n\n  node.intersect = function(point) {\n    return intersectEllipse(node, rx, ry, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction circle(parent, bbox, node) {\n  var r = Math.max(bbox.width, bbox.height) / 2,\n      shapeSvg = parent.insert(\"circle\", \":first-child\")\n        .attr(\"x\", -bbox.width / 2)\n        .attr(\"y\", -bbox.height / 2)\n        .attr(\"r\", r);\n\n  node.intersect = function(point) {\n    return intersectCircle(node, r, point);\n  };\n\n  return shapeSvg;\n}\n\n// Circumscribe an ellipse for the bounding box with a diamond shape. I derived\n// the function to calculate the diamond shape from:\n// http://mathforum.org/kb/message.jspa?messageID=3750236\nfunction diamond(parent, bbox, node) {\n  var w = (bbox.width * Math.SQRT2) / 2,\n      h = (bbox.height * Math.SQRT2) / 2,\n      points = [\n        { x:  0, y: -h },\n        { x: -w, y:  0 },\n        { x:  0, y:  h },\n        { x:  w, y:  0 }\n      ],\n      shapeSvg = parent.insert(\"polygon\", \":first-child\")\n        .attr(\"points\", points.map(function(p) { return p.x + \",\" + p.y; }).join(\" \"));\n\n  node.intersect = function(p) {\n    return intersectPolygon(node, points, p);\n  };\n\n  return shapeSvg;\n}\n","var _ = require(\"./lodash\");\n\n// Public utility functions\nmodule.exports = {\n  isSubgraph: isSubgraph,\n  edgeToId: edgeToId,\n  applyStyle: applyStyle,\n  applyClass: applyClass,\n  applyTransition: applyTransition\n};\n\n/*\n * Returns true if the specified node in the graph is a subgraph node. A\n * subgraph node is one that contains other nodes.\n */\nfunction isSubgraph(g, v) {\n  return !!g.children(v).length;\n}\n\nfunction edgeToId(e) {\n  return escapeId(e.v) + \":\" + escapeId(e.w) + \":\" + escapeId(e.name);\n}\n\nvar ID_DELIM = /:/g;\nfunction escapeId(str) {\n  return str ? String(str).replace(ID_DELIM, \"\\\\:\") : \"\";\n}\n\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n\nfunction applyClass(dom, classFn, otherClasses) {\n  if (classFn) {\n    dom\n      .attr(\"class\", classFn)\n      .attr(\"class\", otherClasses + \" \" + dom.attr(\"class\"));\n  }\n}\n\nfunction applyTransition(selection, g) {\n  var graph = g.graph();\n\n  if (_.isPlainObject(graph)) {\n    var transition = graph.transition;\n    if (_.isFunction(transition)) {\n      return transition(selection);\n    }\n  }\n\n  return selection;\n}\n","module.exports = \"0.4.18-pre\";\n"],"sourceRoot":"/source/"}